---
title: "R Notebook"
output: html_notebook
editor_options: 
  markdown: 
    wrap: 72
---

== opcode listing ==

**halt: 0**

stop execution and terminate the program

**set: 1 a b**

set register <a> to the value of <b>

**push: 2 a**

push <a> onto the stack

**pop: 3 a**

remove the top element from the stack and write it 
into <a>; empty stack = error

**eq: 4 a b c**

set <a> to 1 if <b> is equal to <c>; set it to 0 otherwise

**gt: 5 a b c**

set <a> to 1 if <b> is greater than <c>; set it to 0
otherwise

**jmp: 6 a**

jump to <a>

**jt: 7 a b**

if <a> is nonzero, jump to <b>

**jf: 8 a b**

if <a> is zero, jump to <b>

**add: 9 a b c**

assign into <a> the sum of <b> and <c> (modulo 32768)

**mult: 10 a b c**

store into <a> the product of <b> and <c> (modulo 32768)

**mod: 11 a b c**

store into <a> the remainder of <b> divided by <c>

**and: 12 a b c**

stores into <a> the bitwise and of <b> and <c>

**or: 13 a b c**

stores into <a> the bitwise or of <b> and <c>

**not: 14 a b**

stores 15-bit bitwise inverse of <b> in <a>

**rmem: 15 a b**

read memory at address <b> and write it to <a>

**wmem: 16 a b**

write the value from <b> into memory at address <a>

**call: 17 a**

write the address of the next instruction to the stack and
jump to <a>

**ret: 18**

remove the top element from the stack and jump to it; empty
stack = halt

**out: 19 a**

write the character represented by ascii code <a> to the
terminal

**in: 20 a**

read a character from the terminal and write its ascii code to
<a>; it can be assumed that once input starts, it will continue until a
newline is encountered; this means that you can safely read whole lines
from the keyboard and trust that they will be fully read 

**noop: 21**

no operation

```{r}
raw <- file("C:/Users/cyrus/GitHere/vm-challenge-r/materiel/challenge.bin", "rb")
cmdlist <- readBin(raw, integer(), n = 100000, size = 2, endian = "little", signed = FALSE)
rm(raw)
```

```{r}
library(data.table)
library(stringr)
library(tictoc)

#implement print queue
printqueue <- c()

#let's learn about our opcodes.
takes2 <- c(1,7,8,14,15,16)
takes0 <- c(21,18,0)
takes1 <- c(2,3,6,19,20)
takes3 <- c(13,12,11,10,9,5,4)

counteR <- function() {
  from <- do_next 
  c <- memory[z == (from), cmd]
  memory[z == (from),  `:=` (do = TRUE,
                             done = FALSE)]
  if (isFALSE(c %in% c(takes1, takes2, takes3))) {
    stop_at <<- from #default to one line at a time to lower impact of fuckups maybe 
  }
  if (isTRUE(c %in% takes1)) {
    stop_at <<- from + 1 #stop after one more line of arguments 
  }
  if (isTRUE(c %in% takes2)) {
    stop_at <<- from + 2 #stop after two arguments
  }
  if (isTRUE(c %in% takes3)) {
    stop_at <<- from + 3
  }
  if (isFALSE(c %in% takes0)) {
    do_with <- do_next + 1 
    memory[between(z, (do_with), (stop_at)), 
           `:=` (do = FALSE,
                 done = FALSE)] #if we take one or more arguments, mark them as such 
  }
#  memory[(z > stop_at & !(done == TRUE)), do := as.logical(NA)] #either this is indispensable or it's going to produce infinite loops. let's find out!
  return(invisible(NULL))
}


#metafunctions for things I didn't have the patience to repeat per opcode 
meta_pop <- function() {
  stopifnot(length(stack) > 0) #add more sophisticated error-handling to the popper functions later 
  obj <- stack[1]
  stack <<- stack[-1]
  obj
}

interpret <- function(x) { 
  y <- x %% 32768
  y
}

do_place <- function(x) {  #either interpret a literal value, or read from the register 
  if (isTRUE(x >= 32768)) {
    xval <- interpret(x)
    a <- registers[z == (xval), val]
    print(paste("do_place retrieved", as.character(a), "from the registers"))
    a
  } else {
    a <- interpret(x)
    print(paste("do_place interpreted", as.character(a)))
    a
  }
  a
}

do_read <- function(a) { #read address a 
  if (isTRUE(a < 32768)) {
    x <- memory[z == (a), cmd]
    print(paste("do_read read", as.character(x), "from memory"))
    x
  } else {
    aval <- interpret(a)
    x <- registers[z == (aval), val]
    print(paste("do_read read", as.character(x), "from registers"))
    x
  }
  x
}

do_write <- function(value, to) {
  if (isTRUE(to < 32768)) {
    memory[z == (to), cmd := (value)]
    print(paste("do_write wrote value", value, "to memory at address z = ", to))
  } else {
    toval <- interpret(to)
    registers[z == (toval), val := (value)]
    print(paste("do_write wrote value", value, "to registers at address z =", to))
  }
  return(invisible(NULL))
}

#arguments are always a vector of the a/b/c values expected, then 'loc' as the location of the next valid command whenever doing things.

find <- function(after) { 
  #TESTING
  stopifnot(is.numeric(after))
  do_next <<- after 
  counteR()
  return(invisible(NULL))
} 

finish <- function() { 
  from <- do_next 
  to <- stop_at 
  memory[between(z, (from), (to)), done := TRUE]
  do_next <<- to + 1 
  stop_at <<- do_next 
  counteR()
  return(invisible(NULL))
}

###########################

op_00_halt <- \(loc) {
  print(paste("Program is terminating at location", as.character(loc), "for opcode 0"))
  do_next <<- 32768
  return(invisible(NULL))
}

op_01_set <- \(vec, loc) { #expect vector of address a, value b; loc we're coming from loc
  a <- interpret(vec[1])
  b <- do_place(vec[2])
  print(paste("Attempted to set register", as.character(a), "to value", as.character(b), "at line", as.character(loc)))
  registers[z == (a), val := (b)]
  finish()
  return(invisible(NULL))
}

op_02_push <- \(a, loc) { #expect a and loc
  stack <<- c(a, stack) #taking a here literally until proven otherwise on the assumption that if it wants to undergo do_place() that'll happen later.
  finish()
  return(invisible(NULL))
}

#remove the top element from the stack and write it into <a>; empty stack = error
op_03_pop <- \(a, loc) {
  obj <- meta_pop()
  do_write(obj, a)
  finish()
  return(invisible(NULL))
}

#  set <a> to 1 if <b> is equal to <c>; set it to 0 otherwise
op_04_eq <- \(vec, loc) {
  a <- vec[1]
  b <- do_place(vec[2]) #TODO: evaluate if 'do_place()' is less intuitive than I want it to be as far as "name of the function that checks if a value is literal or a register address"
  c <- do_place(vec[3])
  if (identical(b, c)) {
    do_write(1, a)
  } else {
    do_write(0, a)
  }
  finish()
  return(invisible(NULL))
}

#  set <a> to 1 if <b> is greater than <c>; set it to 0 otherwise
op_05_gt <- \(vec, loc) {
  a <- vec[1]
  b <- do_place(vec[2])
  c <- do_place(vec[3])
  if (b > c) {
    do_write(1, a)
  } else {
    do_write(0, a)
  }
  finish()
  return(invisible(NULL))
}

op_06_jmp <- function(a, loc) {
  x <- do_place(a)
  #TESTING 
  jmpmsg <- c("Attempt jump to:", as.character(x), "from:", as.character(loc))
  finish()
  find(after = x) 
  print(jmpmsg)
  return(invisible(NULL))
}

#  if <a> is nonzero, jump to <b>
op_07_jt <- \(vec, loc) {
  a <- do_place(vec[1])
  b <- do_place(vec[2])
  if (isTRUE(a > 0)) {
    print(paste("jt: attempting jump to", as.character(b), "based on value of <a> = ", as.character(a), ", from", as.character(loc)))
#    op_06_jmp(b, loc)
    finish()
    do_next <<- b 
  } else {
    finish()
  }
  print(paste("jt done, moving to", as.character(do_next)))
  return(invisible(NULL))
}

#  if <a> is zero, jump to <b>
op_08_jf <- \(vec, loc) {
  a <- do_place(vec[1])
  b <- do_place(vec[2])
#  b <- vec[2] #remember op 6 handles 
  if (isTRUE(a < 1)) {
    print(paste("jf: attempting jump to", as.character(b), "based on value <a> =", as.character(a), "from", as.character(loc)))
#    op_06_jmp(b, loc)
    finish()
    do_next <<- b
  } else {
    finish()
  }
  print(paste("jf done, moving to", as.character(do_next)))
  return(invisible(NULL))
}

#  assign into <a> the sum of <b> and <c> (modulo 32768)
op_09_add <- \(vec, loc) {
  a <- vec[1]
  b <- do_place(vec[2])
  c <- do_place(vec[3])
  got <- (b + c) |> interpret()
  do_write(got, a)
  finish()
  return(invisible(NULL))
}

#  store into <a> the product of <b> and <c> (modulo 32768)
op_10_mult <- \(vec, loc) {
  a <- vec[1] 
  b <- do_place(vec[2])
  c <- do_place(vec[3])
  got <- (b * c) |> interpret()
  do_write(got, a)
  finish()
  return(invisible(NULL))
}

#  store into <a> the remainder of <b> divided by <c> ### is this one supposed to be modulo 32768 or not??
op_11_mod <- \(vec, loc) {
  a <- vec[1] 
  b <- do_place(vec[2])
  c <- do_place(vec[3])
  got <- (b %% c) # |> interpret() #???
  do_write(got, a)
  finish()
  return(invisible(NULL))
}

 # stores into <a> the bitwise and of <b> and <c>
op_12_and <- \(vec, loc) {
  a <- vec[1]
  b <- do_place(vec[2])
  c <- do_place(vec[3])
  bits <- bitwAnd(b, c)
  do_write(bits, a)
  finish()
  return(invisible(NULL))
}

#  stores into <a> the bitwise or of <b> and <c>
op_13_or <- \(vec, loc) {
  a <- vec[1]
  b <- do_place(vec[2])
  c <- do_place(vec[3])
  bits <- bitwOr(b, c)
  do_write(bits, a)
  finish()
  return(invisible(NULL))
}

#stores 15-bit bitwise inverse of <b> in <a>
op_14_not <- \(vec, loc) {
  a <- vec[1]
  b <- vec[2]
  c <- vec[3]
  bits <- bitwNot(b, c)
  do_write(bits, a)
  finish()
  return(invisible(NULL))
}

#  read memory at address <b> and write it to <a>
op_15_rmem <- \(vec, loc) { #expect numeric vector of length 2 that breaks into a, b
  #this explicitly says "read memory" but frankly I'm not sure there's harm in do_read()ing it so fuck it 
  bval <- do_read(vec[2])
  aval <- do_place(vec[1]) #I also don't trust this not to be potentially register in a hat 
#  a <- vec[1]
  do_write(bval, aval)
  finish()
  return(invisible(NULL))
}

#  write the value from <b> into memory at address <a>
op_16_wmem <- \(vec, loc) { # expect numeric vector of length 2 that breaks into a, b
  #allegedly b will reliably be a register address this time.
  a <- vec[1]
  bloc <- interpret(vec[2]) #change to do_read() if that's a lie though
  bval <- registers[z == (bloc), val]
  do_write(bloc, a) #TODO: check if this is understanding the logic correctly 
  finish()
  return(invisible(NULL))
}

#call: 17 a
#  write the address of the next instruction to the stack and jump to <a>
op_17_call <- \(a, loc) {
  write_next <- memory[(z > (loc)) & (do == TRUE) & (done == FALSE), z][1]
  stack <<- c(write_next, stack)
  op_6_jmp(a, loc)
  return(invisible(NULL))
}

op_18_ret <- \(loc) {
  if (isTRUE(length(stack) < 1)) { 
    op_00_halt() #call existing halt
    #alternately: #if the stack is empty, set main up to halt 
  #  memory[z < 32767, done := TRUE]
  #  memory[z == 32767, `:=` (done = FALSE,
                          #   cmd = 0)]
  } else { 
    place <- meta_pop() # |> do_place(place) # is this needed?
    find(place)
  }
  finish() # mark this as done to avoid loops
  return(invisible(NULL))
}

op_19_out <- \(a, loc) {
  aval <- do_place(a[1])
  ch <- rawToChar(as.raw(aval))
  printqueue <<- c(printqueue, ch)
  finish()
  return(invisible(NULL))
}

op_20_in <- \(a, loc) {
  str <- readline()
  split <- strsplit(str)
  for (i in seq_len(length(str))) {
    go <- a + (i - 1)
    char <- charToRaw(str[[i]])
    do_write(char, go)
  }
  finish()
  return(invisible(NULL))
}

op_21_noop <- \(loc) {
  print("......pausing to note noop.......")
  finish()
  return(invisible(NULL))
}

sendeR <- function(memory) {
  find(do_next)
  vec <- memory[between(z, (do_next), (stop_at)), cmd] #does safely return the only value if do_next = stop_at, I checked 
  do_this <- memory[z == do_next, cmd]
  stopifnot(do_this <= 21) #stop if we've been passed a non-viable command somehow 
  vec <- vec[-1]
  if (do_this != 19) {
    if (!is.null(printqueue)) {
      cat(printqueue, sep = "")
      print("[End printing.]")
      printqueue <<- c()
    }
  }
  if (do_this == 0) {
    op_00_halt(do_next)
  } 
  if(do_this == 1) {
    op_01_set(vec, do_next)
  }
  if(do_this == 2) {
    op_02_push(vec, do_next)
  }
  if(do_this == 3) {
    op_03_pop(vec, do_next)
  }
  if(do_this == 4) {
    op_04_eq(vec, do_next)
  }
  if(do_this == 5) {
    op_05_gt(vec, do_next)
  }
  if(do_this == 6) {
    op_06_jmp(vec, do_next)
  }
  if(do_this == 7) {
    op_07_jt(vec, do_next)
  }
  if(do_this == 8) {
    op_08_jf(vec, do_next)
  }
  if(do_this == 9) {
    op_09_add(vec, do_next)
  }
  if(do_this == 10) {
    op_10_mult(vec, do_next)
  }
  if(do_this == 11) {
    op_11_mod(vec, do_next)
  }
  if(do_this == 12) {
    op_12_and(vec, do_next)
  }
  if(do_this == 13) {
    op_13_or(vec, do_next)
  }
  if(do_this == 14) {
    op_14_not(vec, do_next)
  }
  if(do_this == 15) {
    op_15_rmem(vec, do_next)
  }
  if(do_this == 16) {
    op_16_wmem(vec, do_next)
  }
  if(do_this == 17) {
    op_17_call(vec, do_next)
  }
  if(do_this == 18) {
    op_18_ret(vec, do_next)
  }
  if(do_this == 19) {
    op_19_out(vec, do_next)
  }
  if(do_this == 20) {
    op_20_in(vec, do_next)
  }
  if (do_this == 21) {
    op_21_noop(do_next)
  }
  counteR()
  return(invisible(NULL))
}

understandeR <- function(cmds = cmdlist) { #comma-separated list of integers unbinaried from binary goes here
  stopifnot(is.integer(cmds)) #stop if the input vector isn't made of numbers
  stopifnot(cmds[1] >= 0)
  stopifnot(cmds[1] <= 21) #stop if the first argument isn't a legal command that we know 
  
  #places things live
  registers <<- data.table(
    z = 0:7,
    val = c(rep(0, 8))) #replace with as.numeric(NA) if it's not supposed to be implicit 0  
  stack <<- c()
  
  pad <- 32768 - length(cmds)
  memories <- c(cmds, rep(0, pad))
  memory <<- data.table( #SUPERASSIGN FOR TESTING ONLY
    #THIS ONE /DOES/ GET CUT DOWN LATER! 
    z = 0:32767, #compensate for 0-indexing
    cmd = memories, #fill out memory space 
    do = rep(as.logical(NA), 32768), #add a boolean column to find commands 
    done = rep(as.logical(NA), 32768) #mark commands that have been executed
  )
  rm(pad, memories)
  setkey(memory, z)
  setorder(memory, z)
  memory[cmd >= 32776, cmd := 0] #remove illegal numbers 

  #big magic wherein we actually go through the table in an unavoidable while loop happens here 
  if (isFALSE(do_next == 0)) {
    do_next <<- 0 
    stop_at <<- 0 
  }
  while (do_next < 32768) {
    if (isTRUE(stop_at < 32768)) {
      sendeR(memory)
    }
  }
  fwrite(memory, file = "C:/Users/cyrus/GitHere/vm-challenge-r/latest_run.csv")
  print("Counter reached 32768; program ends.")
  return(invisible(NULL))
}
```

```{r}
tic()
understandeR(cmdlist)
toc()
```
