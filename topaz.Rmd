---
title: "R Notebook"
output: html_notebook
editor_options: 
  markdown: 
    wrap: 72
---

== architecture == - three storage regions - memory with 15-bit address
space storing 16-bit values - eight registers - an unbounded stack which
holds individual 16-bit values - all numbers are unsigned integers
0..32767 (15-bit) - all math is modulo 32768; 32758 + 15 =\> 5

== binary format == - each number is stored as a 16-bit little-endian
pair (low byte, high byte) - numbers 0..32767 mean a literal value -
numbers 32768..32775 instead mean registers 0..7 - numbers 32776..65535
are invalid - programs are loaded into memory starting at address 0 -
address 0 is the first 16-bit value, address 1 is the second 16-bit
value, etc

== execution == - After an operation is executed, the next instruction
to read is immediately after the last argument of the current operation.
If a jump was performed, the next operation is instead the exact
destination of the jump. - Encountering a register as an operation
argument should be taken as reading from the register or setting into
the register as appropriate.

== hints == - Start with operations 0, 19, and 21. - Here's a code for
the challenge website: FblmAujZTsSw - The program
"9,32768,32769,4,19,32768" occupies six memory addresses and should: -
Store into register 0 the sum of 4 and the value contained in
register 1. - Output to the terminal the character with the ascii code
contained in register 0.

== opcode listing ==

**halt: 0 **

stop execution and terminate the program

**set: 1 a b **

set register <a> to the value of <b>

**push: 2 a**

push <a> onto the stack

**pop: 3 a **

remove the top element from the stack and write it into <a>;
empty stack = error

**eq: 4 a b c **

set <a> to 1 if <b> is equal to <c>; set it to 0 otherwise

**gt: 5 a b c **

set <a> to 1 if <b> is greater than <c>; set it to 0
otherwise

**jmp: 6 a **

jump to <a>

**jt: 7 a b**

if <a> is nonzero, jump to <b>

**jf: 8 a b**

if <a> is zero, jump to <b>

**add: 9 a b c **

assign into <a> the sum of <b> and <c> (modulo 32768)

**mult: 10 a b c **

store into <a> the product of <b> and <c> (modulo 32768)

**mod: 11 a b c **

store into <a> the remainder of <b> divided by <c>

**and: 12 a b c **

stores into <a> the bitwise and of <b> and <c>

**or: 13 a b c **

stores into <a> the bitwise or of <b> and <c>

**not: 14 a b **

stores 15-bit bitwise inverse of <b> in <a>

**rmem: 15 a b **

read memory at address <b> and write it to <a>

**wmem: 16 a b**

write the value from <b> into memory at address <a>

**call: 17 a**

write the address of the next instruction to the stack and
jump to <a>

**ret: 18**

remove the top element from the stack and jump to it; empty
stack = halt

**out: 19 a**

write the character represented by ascii code <a> to the
terminal

**in: 20 a **

read a character from the terminal and write its ascii code to
<a>; it can be assumed that once input starts, it will continue until a
newline is encountered; this means that you can safely read whole lines
from the keyboard and trust that they will be fully read 

**noop: 21**

no operation

```{r}
raw <- file("C:/Users/cyrus/GitHere/vm-challenge-r/materiel/challenge.bin", "rb")
cmdlist <- readBin(raw, integer(), n = 100000, size = 2, endian = "little")
rm(raw)
```

```{r}
library(data.table)
library(stringr)

#implement print queue
printqueue <- c()

#let's learn about our opcodes.
takes2 <- c(1,7,8,14,15,16)
takes0 <- c(21,18,0)
takes1 <- c(2,3,6,19,20)
takes3 <- c(13,12,11,10,9,5,4)

counteR <- function() {
  from <- do_next 
  c <- memory[z == (from), cmd]
  memory[z == (from),  `:=` (do = TRUE,
                             done = FALSE)]
  i <- from + 1
  if (isTRUE(c %in% takes0)) {
    stop_at <<- from 
  }
  if (isFALSE(c %in% takes0)) {
    memory[z == (i), `:=` (do = FALSE,
                           done = FALSE)] #if we take one or more arguments, mark the immediate next line
  }
  if (isTRUE(c %in% takes1)) {
    stop_at <- from + 1
  }
  if (isTRUE(c %in% c(takes2, takes3))) {
    i <- i + 1
    memory[z == (i), `:=` (do = FALSE,
                           done = FALSE)] #mark second argument if two arguments are taken
  }
  if (isTRUE(c %in% takes2)) {
    stop_at <<- from + 2
  }
  if (isTRUE(c %in% takes3)) { #I think I should be able to change the meaning of i in the above if and only make this one mark the third but I don't trust Sunday night me with that enough to have that be the thing that breaks right this minute, thanks.
    i <- i + 1
    memory[z == (i), `:=` (do = FALSE,
                           done = FALSE)]
    stop_at <<- from + 3
  }
#  memory[(z > i & !(done == TRUE)), do := as.logical(NA)] #either this is indispensable or it's going to produce infinite loops. let's find out!
  return(invisible(NULL))
}

#places things live
registers <- data.table(
  z = 0:7,
  val = c(rep(as.numeric(NA), 8)))
stack <- c()

#metafunctions for things I didn't have the patience to repeat per opcode 
meta_pop <- function() {
  stopifnot(length(stack) > 0) #add more sophisticated error-handling to the popper functions later 
  obj <- stack[1]
  stack <<- stack[-1]
  obj
}

interpret <- function(x) { 
  y <- x %% 32768
  y
}

do_place <- function(x) {  #either interpret a literal value, or read from the register 
  if (isTRUE(x >= 32768)) {
    xval <- interpret(x)
    a <- registers[z == (xval), val]
    a
  } else {
    a <- interpret(x)
    a
  }
  a
}

do_read <- function(a) {
  if (isTRUE(a < 32768)) {
    x <- memory[z == (a), cmd]
  } else {
    aval <- interpret(a)
    x <- registers[z == (aval), val]
  }
  x
}

do_write <- function(value, to) {
  if (isTRUE(to < 32768)) {
    memory[z == (to), cmd := (value)]
  } else {
    toval <- interpret(to)
    registers[z == (toval), val := (value)]
  }
  return(invisible(NULL))
}

#arguments are always a vector of the a/b/c values expected, then 'loc' as the location of the next valid command whenever doing things.

find <- function(after) { 
  #TESTING
  stopifnot(is.numeric(after))
#  if (!is.numeric(after)) { after <- 0 } #default to starting from z=0 if something funny happens
  do_next <<- after 
#  do_next <<- memory[between(cmd, 0, 21), ][(is.na(done) | done == FALSE), ][z >= (after), z][1] |> as.integer() #should get the first of remaining commands? #update: removing and trusting the program instead 
  counteR()
#  stop_at <<- ((memory[z > (do_next), ][is.na(do), z][1]) - 1) |> as.integer() #stop before next legal command
#  memory[between(z, (do_next), (stop_at)), done := FALSE] #try setting this in counteR instead 
  return(invisible(NULL))
#  return(invisible(list(do_next, stop_at))) #we want to hand this up for the multi-argument guys and I'm not yet sure how's best
} 

finish <- function() { 
#  memory[(z == (loc)), done := TRUE] #mark the command with this z-index as done
#  nnext <- loc + nrow(memory[(z > (loc)), ][do == FALSE, ])
  from <- do_next 
  to <- stop_at 
  memory[between(z, (from), (to)), done := TRUE]
  do_next <<- to + 1 
  stop_at <<- do_next 
  counteR()
  return(invisible(NULL))
}

###########################

op_00_halt <- \(loc) {
  do_next <<- 32768
  finish()
#  memory[ , `:=` (do = FALSE,
#                  cmd = 0, #assuming that terminating the program means... wiping memory.
#                  done = TRUE)]
#  rm(memory) #or I guess  r e a l l y  wiping memory?
  print(paste("Program has terminated with opcode 0 at location:", as.character(loc)))
  return(invisible(NULL))
}

op_01_set <- \(vec, loc) { #expect vector of address a, value b; loc we're coming from loc
  a <- do_place(vec[1])
  b <- do_place(vec[2])
  registers[z == (a), val := (b)]
  finish()
  return(invisible(NULL))
}

op_02_push <- \(a, loc) { #expect a and loc
  stack <<- c(a, stack) #taking a here literally until proven otherwise on the assumption that if it wants to undergo do_place() that'll happen later.
  finish()
  return(invisible(NULL))
}

#remove the top element from the stack and write it into <a>; empty stack = error
op_03_pop <- \(a, loc) {
  obj <- meta_pop()
  do_write(obj, a)
  finish()
  return(invisible(NULL))
}

#  set <a> to 1 if <b> is equal to <c>; set it to 0 otherwise
op_04_eq <- \(vec, loc) {
  a <- vec[1]
  b <- do_place(vec[2]) #TODO: evaluate if 'do_place()' is less intuitive than I want it to be as far as "name of the function that checks if a value is literal or a register address"
  c <- do_place(vec[3])
  if (identical(b, c)) {
    do_write(a, 1)
  } else {
    do_write(a, 0)
  }
  finish()
  return(invisible(NULL))
}

#  set <a> to 1 if <b> is greater than <c>; set it to 0 otherwise
op_05_gt <- \(vec, loc) {
  a <- vec[1]
  b <- do_place(vec[2])
  c <- do_place(vec[3])
  if (b > c) {
    do_write(a, 1)
  } else {
    do_write(a, 0)
  }
  finish()
  return(invisible(NULL))
}

op_06_jmp <- function(a, loc) {
  x <- do_place(a)
  #TESTING 
  jmpmsg <- c("Attempt jump to:", as.character(x))
  finish()
  find(after = x) 
  return(jmpmsg)
}

#  if <a> is nonzero, jump to <b>
op_07_jt <- \(vec, loc) {
  a <- do_read(vec[1])
  b <- vec[2]
  if (isTRUE(a > 0)) {
    op_06_jmp(b, loc)
  } else {
    finish()
  }
  return(invisible(NULL))
}

#  if <a> is zero, jump to <b>
op_08_jf <- \(vec, loc) {
  a <- do_read(vec[1])
  b <- vec[2] #remember op 6 handles 
  if (isTRUE(aval < 1)) {
    op_06_jmp(b, loc)
  } else {
    finish()
  }
  return(invisible(NULL))
}

#  assign into <a> the sum of <b> and <c> (modulo 32768)
op_09_add <- \(vec, loc) {
  a <- vec[1]
  b <- do_place(vec[2])
  c <- do_place(vec[3])
  got <- (b + c) |> interpret()
  do_write(got, a)
  finish()
  return(invisible(NULL))
}

#  store into <a> the product of <b> and <c> (modulo 32768)
op_10_mult <- \(vec, loc) {
  a <- vec[1] 
  b <- do_place(vec[2])
  c <- do_place(vec[3])
  got <- (b * c) |> interpret()
  do_write(got, a)
  finish()
  return(invisible(NULL))
}

#  store into <a> the remainder of <b> divided by <c> ### is this one supposed to be modulo 32768 or not??
op_11_mod <- \(vec, loc) {
  a <- vec[1] 
  b <- do_place(vec[2])
  c <- do_place(vec[3])
  got <- (b %% c) # |> interpret() #???
  do_write(got, a)
  finish()
  return(invisible(NULL))
}

 # stores into <a> the bitwise and of <b> and <c>
op_12_and <- \(vec, loc) {
  a <- vec[1]
  b <- do_place(vec[2])
  c <- do_place(vec[3])
  bits <- bitwAnd(b, c)
  do_write(bits, a)
  finish()
  return(invisible(NULL))
}

#  stores into <a> the bitwise or of <b> and <c>
op_13_or <- \(vec, loc) {
  a <- vec[1]
  b <- do_place(vec[2])
  c <- do_place(vec[3])
  bits <- bitwOr(b, c)
  do_write(bits, a)
  finish()
  return(invisible(NULL))
}

#stores 15-bit bitwise inverse of <b> in <a>
op_14_not <- \(vec, loc) {
  a <- vec[1]
  b <- vec[2]
  c <- vec[3]
  bits <- bitwNot(b, c)
  do_write(bits, a)
  finish()
  return(invisible(NULL))
}

#  read memory at address <b> and write it to <a>
op_15_rmem <- \(vec, loc) { #expect numeric vector of length 2 that breaks into a, b
  #this explicitly says "read memory" but frankly I'm not sure there's harm in do_read()ing it so fuck it 
  bval <- do_read(vec[2])
  aval <- do_place(vec[1])
  do_write(bval, aval)
  finish()
  return(invisible(NULL))
}

#  write the value from <b> into memory at address <a>
op_16_wmem <- \(vec, loc) { # expect numeric vector of length 2 that breaks into a, b
  #allegedly b will reliably be a register address this time.
  bloc <- interpret(vec[2]) #change to do_read() if that's a lie though
  bval <- registers[z == (bloc), val]
  do_write(bloc, a) #TODO: check if this is understanding the logic correctly 
  finish()
  return(invisible(NULL))
}

#call: 17 a
#  write the address of the next instruction to the stack and jump to <a>
op_17_call <- \(a, loc) {
  write_next <- memory[(z > (loc)) & (do == TRUE) & (done == FALSE), z][1]
  stack <<- c(write_next, stack)
  op_6_jmp(a, loc)
  return(invisible(NULL))
}

op_18_ret <- \(loc) {
  if (isTRUE(length(stack) < 1)) { 
    op_00_halt() #call existing halt
    #alternately: #if the stack is empty, set main up to halt 
  #  memory[z < 32767, done := TRUE]
  #  memory[z == 32767, `:=` (done = FALSE,
                          #   cmd = 0)]
  } else { 
    place <- meta_pop() # |> do_place(place) # is this needed?
    find(place)
  }
  finish() # mark this as done to avoid loops
  return(invisible(NULL))
}

op_19_out <- \(a, loc) {
  aval <- do_place(a[1])
  ch <- rawToChar(as.raw(aval))
  printqueue <<- c(printqueue, ch)
  finish()
  return(invisible(NULL))
}

op_20_in <- \(a, loc) {
  str <- readline()
  split <- strsplit(str)
  for (i in seq_len(length(str))) {
    go <- a + (i - 1)
    char <- charToRaw(str[[i]])
    do_write(char, go)
  }
  finish()
  return(invisible(NULL))
}

op_21_noop <- \(loc) {
  print("......pausing to note noop.......")
  finish()
  return(invisible(NULL))
}

sendeR <- function(memory) {
  find(do_next)
  vec <- memory[between(z, (do_next), (stop_at)), cmd] #does safely return the only value if do_next = stop_at, I checked 
  do_this <- memory[z == do_next, cmd]
  stopifnot(do_this <= 21) #stop if we've been passed a non-viable command somehow 
  vec <- vec[-1]
  if (do_this != 19) {
    if (!is.null(printqueue)) {
      cat(printqueue, sep = "")
      print("[End printing.]")
      printqueue <<- c()
    }
  }
  if (do_this == 0) {
    op_00_halt(do_next)
  } 
  if(do_this == 1) {
    op_01_set(vec, do_next)
  }
  if(do_this == 2) {
    op_02_push(vec, do_next)
  }
  if(do_this == 3) {
    op_03_pop(vec, do_next)
  }
  if(do_this == 4) {
    op_04_eq(vec, do_next)
  }
  if(do_this == 5) {
    op_05_gt(vec, do_next)
  }
  if(do_this == 6) {
    op_06_jmp(vec, do_next)
  }
  if(do_this == 7) {
    op_07_jt(vec, do_next)
  }
  if(do_this == 8) {
    op_08_jf(vec, do_next)
  }
  if(do_this == 9) {
    op_09_add(vec, do_next)
  }
  if(do_this == 10) {
    op_10_mult(vec, do_next)
  }
  if(do_this == 11) {
    op_11_mod(vec, do_next)
  }
  if(do_this == 12) {
    op_12_and(vec, do_next)
  }
  if(do_this == 13) {
    op_13_or(vec, do_next)
  }
  if(do_this == 14) {
    op_14_not(vec, do_next)
  }
  if(do_this == 15) {
    op_15_rmem(vec, do_next)
  }
  if(do_this == 16) {
    op_16_wmem(vec, do_next)
  }
  if(do_this == 17) {
    op_17_call(vec, do_next)
  }
  if(do_this == 18) {
    op_18_ret(vec, do_next)
  }
  if(do_this == 19) {
    op_19_out(vec, do_next)
  }
  if(do_this == 20) {
    op_20_in(vec, do_next)
  }
  if (do_this == 21) {
    op_21_noop(do_next)
  }
  counteR()
  return(invisible(NULL))
}

understandeR <- function(cmds = cmdlist) { #comma-separated list of integers unbinaried from binary goes here (as a vector! vectorize it!)
  stopifnot(is.integer(cmds)) #stop if the input vector isn't made of numbers
  stopifnot(cmds[1] >= 0)
  stopifnot(cmds[1] <= 21) #stop if the first argument isn't a legal command that we know 
  pad <- 32768 - length(cmds)
  memories <- c(cmds, rep(0, pad))
  memory <<- data.table( #SUPERASSIGN FOR TESTING ONLY
    #THIS ONE /DOES/ GET CUT DOWN LATER! 
    z = 0:32767, #compensate for 0-indexing
    cmd = memories, #fill out memory space 
    do = rep(as.logical(NA), 32768), #add a boolean column to find commands 
    done = rep(as.logical(NA), 32768) #mark commands that have been executed
  )
  rm(pad, memories)
  setkey(memory, z)
  setorder(memory, z)
  memory[cmd >= 32776, cmd := 0] #remove illegal numbers 
#  memory[cmd <= 21 & cmd >= 0, do := TRUE] #label legal commands 

  #big magic wherein we actually go through the table in an unavoidable while loop happens here 
  if (isFALSE(do_next == 0)) {
    do_next <<- 0 
    stop_at <<- 0 
  }
  while (do_next < 32768) {
#    find(do_next)
    if (isTRUE(stop_at < 32768)) {
      sendeR(memory)
    }
  }
  return(invisible(NULL))
}
```

```{r}
understandeR(cmdlist)
```
